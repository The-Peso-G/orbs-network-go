# Merkle Binary Trees / Tries

## Shared Algorithm
This is a basic non public implementation of a **Compact Binary Merkle Tree/Trie**. 
It defines the common algorithm for both Tree and Trie.
Essentially it defines:
* The node in memory is:
   * value : hash code of the value assassinated with the path that is represented by the current node. SHA256 (32B).
   * left/right : left and right child pointers, 
   * prefix : decompressed partial path (list of bytes each one is a 1 or 0)
   * node-hash : hash of this node specified for [Tree](Merkle Binary Trie Forest Hash)/[Trie](Merkle Binary Ordered Tree Hash) implementation. SHA256 (32B). 
* The insert function that allows adding a new key/value to a tree by generating 
a new node pointer. This function should be called multiple times to update a tree with 
many values as it does not hash or trim the tree. Note insert needs a "dirty" cache also defined in this package.
* The collapseAndHash function is called after the insert to compact the tree and run the hash 
function from the leafs upwards (using the dirty cache to limit action only on changed nodes).

The algo-implementation supports multi-length keys, so non-leafs may have a value. 

Zero-Hash is defined as hash of 32 bytes of 0.

These common functions are used to build two public implementations of Merkle:

##  Merkle Binary Trie Forest
The input is a list of Key/Value pair. Each tree after creation is immutable.
We use a forest implementation that keeps several past trees with their root pointers 
and in each update only new nodes (including root node) are created. This has the advantage of
using the go GC to remove unused nodes when we discard a root node.

The implementation assumes a fixed size of key upto 32 Bytes. In This implies :
* Only leaf nodes have assigned Values.
* Non leaf nodes have **exactly 2 children** (left/right). 
* Note: Adding nodes with different length will not fail, but the proof/verify functions may not work.

#### Merkle Binary Trie Forest Hash
* Leaf node : `hash {value, prefix}`
* Core node : `hash {left child's node-hash, right child's node-hash, prefix}`

Please note, since only leaf nodes use value in hashing, entries with key length shorter than the
 maximal key length may not participate in the the Merkle root and will not be able to create valid proofs.

#### Binary Merkle Trie Forest Proof
Provides inclusion / exclusion authentication for arbitrary keys. 

For inclusion proofs PATH represents the requested key. 
For exclusion proofs PATH represents a key from the tree which has the longest prefix matching the requested key, but with divergent ending that shows
that the path cannot proceed in the direction of the requested key. 
Having a valid proof for the existence of a different PATH proves the exclusion of the requested key. 

The proof is generated by traversing the tree from the root core node along the PATH towards a requested key
leaf and its value. For each core node one child will be the next element on the PATH (child-on-PATH) and it's sibling will be not be
on PATH (child-off-PATH).
In each step record the node's child-off-PATH's hash and current prefix size, then travel to the child-on-PATH node.
The last node records the desired leaf's hash (inclusion) or first node that proves divergence from PATH's hash (exclusion) and that node's prefix size.
This allows verifying the proof by calculating "bottom-up" the node hashes, arriving and the Merkle Root.


##### Structure:
A proof is made of a variable number of nodes of 33 bytes each, followed by
32 bytes of a value-hash and 32 bytes of PATH. 

```{List of nodes (33B each), Value-Hash (32B), Path (32B)}```

* List of parent nodes: {hash of the child-off-PATH (32B), self prefix size (1B)}
* Last node: {hash of last node of PATH (32B), prefix of last node of PATH (1B)} 
* Value-hash : Hash Value of last node of PATH (needed for exclusion)
* Path: PATH of proof (needed for exclusion - to show divergence from requested key)

Each node includes the additional information needed to calculate the Trie core node hash. 
In an inclusion proof the final node is a leaf node. 
In an exclusion proof the final node may be a leaf or a core node. It is the first divergent node from PATH.

##### Proof validation: 
  * Step 1: check consistence of proof with requested key by calculating the node chain hashes
     * current_hash = hash of last node (included in proof)
     * key_pos = size of key 
     * For each node in the proof starting from last parent node
        * key_pos -= size of prefix of current node
        * if key bit at key_pos == 0
            * current_hash = hash{current_hash, node hash, node prefix}
        * else 
            * current_hash = hash{node hash, current_hash, node prefix}
       * 
     * result must be equal to the Merkle root hash (otherwise error)
  * Step 2: check inclusion/ exclusion
     * inclusion: if requested value is non zero-hash
        * calculate_hash = hash{requested value, prefix of last node}
        * return calculate_hash == hash of last node (included in proof)
     * exclusion: if requested value is zero-hash
        * calculate_hash = hash{value-hash included in proof, prefix from path included in proof}
        * exclusion is proved if
            * calulate_hash == hash of last node (included in proof)
            * requested key is equal to PATH - without LSB prefix size of Last node
            * requested key is NOT equal to proof Path - in LSB prefix size of Last node
        * if requery and proof PATH size are not equal - error


## Merkle Binary Ordered Tree
The input is a list of values. The order of the values determains the tree.
Tree is immutable and only used to get proofs by index of value in original list.

Note we use order the two 

* Tree type: Binary Merkle Tree
* Value: SHA256 (32B)
* Hash: SHA256 (32B)

#### Merkle Binary Ordered Tree Hash
* Leaf node : {Value}
* Core node : hash{Min(left_child_hash, right_child_hash), Max(left_child_hash, right_child_hash)}

#### Merkle Binary Ordered Tree Proof
Proofs : Provides inclusion authentication for sequential values (0 - max_index)..
To maintain a short proof the key size if the ceiling of the log2 of the number of values.

* Structure:
  * List of ceiling(log(max_index)) core nodes' hash.

* Proof validation:
  * hash_state = the value tested
  * key_bit = proof length - 1
  * For each node in the proof starting from the last
      * hash_state = hash{Min(hash_state, node), Max(hash_state, node)}
    * key_bit--
  * Compare the hash_state with the tree root.

